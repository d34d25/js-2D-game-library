class t{constructor(t=0,i=0,s=10,e=10){this.minX=t,this.minY=i,this.maxX=s,this.maxY=e}}const i=5e-4;function s(t,i){return t.x*i.x+t.y*i.y}function e(t,i){return t.x*i.y-t.y*i.x}function n(t,i){return{x:t.x+i.x,y:t.y+i.y}}function a(t,i){return{x:t.x-i.x,y:t.y-i.y}}function o(t,i){return{x:t.x*i.x,y:t.y*i.y}}function r(t,i){return{x:t.x*i,y:t.y*i}}function l(t){return Math.sqrt(t.x*t.x+t.y*t.y)}function c(t){const i=l(t);return 0===i?{x:0,y:0}:{x:t.x/i,y:t.y/i}}function y(t,i,s){return Math.min(Math.max(t,i),s)}function h(t,s){return Math.abs(t-s)<i}function x(t,i){return u(t,i)<25e-8}function u(t,i){let s=t.x-i.x,e=t.y-i.y;return s*s+e*e}function m(t){return t.x*t.x+t.y*t.y}function d(t,i){let s=t.x-i.x,e=t.y-i.y;return Math.sqrt(s*s+e*e)}class p{static updatedBodiesCount=0;constructor(i,s,e,n,a){this.position=i,this.angle=0,this.linearVelocity={x:0,y:0},this.angularVelocity=0,this.linearDamping={x:0,y:0},this.angularDamping=0,this.staticFriction=.6,this.dynamicFriction=.4,this.mass=1,this.force={x:0,y:0},this.torque=0,this.restitution=e,this.inertia=1/0,this.density=s,this.size={w:1,h:1},this.radius=1,this.vertices=[],this.isStatic=n,this.rotates=a,this.affectedByGravity=!0,this.type="",this.types=["box","triangle","circle"],this.aabb=new t,this.FORCE_MULTIPLIER=7250,this.TORQUE_MULTIPLIER=2e4}get isBox(){return this.type===this.types[0]}get isTriangle(){return this.type===this.types[1]}get isCircle(){return this.type===this.types[2]}get invMass(){return this.mass===1/0||0===this.mass?0:1/this.mass}get invInertia(){return this.inertia===1/0||0===this.inertia?0:1/this.inertia}get transformedVertices(){let t=Math.cos(this.angle),i=Math.sin(this.angle),s=this.position;return this.vertices.map(({x:e,y:n})=>({x:s.x+e*t-n*i,y:s.y+e*i+n*t}))}get hasInfiniteMass(){return this.mass===1/0}move(t){this.position.x+=t.x,this.position.y+=t.y,this.needsUpdate=!0,this.aabbNeedsUpdate=!0}setPosition(t){this.position.x=t.x,this.position.y=t.y,this.needsUpdate=!0,this.aabbNeedsUpdate=!0,f(this)}rotate(t){this.angle+=t,this.needsUpdate=!0,this.aabbNeedsUpdate=!0}setAngle(t){this.angle=t,this.needsUpdate=!0,this.aabbNeedsUpdate=!0,f(this)}addForce(t){this.force={x:t.x*this.FORCE_MULTIPLIER,y:t.y*this.FORCE_MULTIPLIER},this.needsUpdate=!0,this.aabbNeedsUpdate=!0}addTorque(t){this.torque=t*this.TORQUE_MULTIPLIER,this.needsUpdate=!0,this.aabbNeedsUpdate=!0}setLinearVelocity(t){this.linearVelocity=t,this.needsUpdate=!0,this.aabbNeedsUpdate=!0}setAngularVelocity(t){this.angularVelocity=t,this.needsUpdate=!0,this.aabbNeedsUpdate=!0}createBox(){let t=this.size.w/2,i=this.size.h/2;this.vertices=[{x:-t,y:-i},{x:t,y:-i},{x:t,y:i},{x:-t,y:i}],this.type=this.types[0]}createTriangle(){let t=this.size.w/2,i=this.size.h;this.vertices=[{x:-t,y:0},{x:t,y:0},{x:0,y:-i}],this.type=this.types[1]}createCircle(){this.type=this.types[2]}updateBody(t,i={x:0,y:9.8},s){if(this.isStatic)return;t/=s;let e={x:0,y:0},n=0;e.x+=this.force.x/this.mass,e.y+=this.force.y/this.mass,this.affectedByGravity&&(e.x+=i.x,e.y+=i.y),this.linearVelocity.x+=e.x*t,this.linearVelocity.y+=e.y*t,this.linearVelocity.x*=Math.pow(1-this.linearDamping.x,t),this.linearVelocity.y*=Math.pow(1-this.linearDamping.y,t),this.position.x+=this.linearVelocity.x*t,this.position.y+=this.linearVelocity.y*t,n+=this.torque/this.inertia,this.angularVelocity+=n*t,this.angle+=this.angularVelocity*t,this.angularVelocity*=Math.pow(1-this.angularDamping,t),f(this),this.force.x=0,this.force.y=0}}function f(t){const i=t.aabb;if(t.isCircle)i.minX=t.position.x-t.radius,i.maxX=t.position.x+t.radius,i.minY=t.position.y-t.radius,i.maxY=t.position.y+t.radius;else{const s=t.transformedVertices;i.minX=1/0,i.maxX=-1/0,i.minY=1/0,i.maxY=-1/0;for(let t=0;t<s.length;t++){const e=s[t];e.x<i.minX&&(i.minX=e.x),e.x>i.maxX&&(i.maxX=e.x),e.y<i.minY&&(i.minY=e.y),e.y>i.maxY&&(i.maxY=e.y)}}}function g({position:t={x:0,y:0},size:i={w:10,h:10},density:s=1,restitution:e=.5,linearDamping:n={x:0,y:0},angularDamping:a=0,isStatic:o=!1,noRotation:r=!1,affectedByGravity:l=!0,dynamicFriction:c=.4,staticFriction:y=.6}={}){const h=new p(t,s,e,o,r);h.size=i;const x=h.size.w*h.size.h;return h.createBox(),h.mass=1/0,h.inertia=1/0,h.linearDamping=n,h.angularDamping=a,h.staticFriction=y,h.dynamicFriction=c,h.affectedByGravity=l,f(h),h.isStatic||(h.mass=x*h.density,h.inertia=1/12*h.mass*(h.size.w*h.size.w+h.size.h*h.size.h)),h.needsUpdate=!0,h}function v({position:t={x:0,y:0},size:i={w:10,h:10},density:s=1,restitution:e=.5,linearDamping:n={x:0,y:0},angularDamping:a=0,isStatic:o=!1,noRotation:r=!1,affectedByGravity:l=!0,dynamicFriction:c=.4,staticFriction:y=.6}={}){const h=new p(t,s,e,o,r);h.size=i,h.createTriangle(),h.mass=1/0,h.inertia=1/0;const x=h.size.w,u=h.size.h;if(h.linearDamping=n,h.angularDamping=a,h.staticFriction=y,h.dynamicFriction=c,h.affectedByGravity=l,f(h),!h.isStatic){const t=.5*h.size.w*h.size.h;h.mass=t*s,h.inertia=h.mass*(x*x+u*u)/36}return h.needsUpdate=!0,h}function V({position:t={x:0,y:0},radius:i=10,density:s=1,restitution:e=.5,linearDamping:n={x:0,y:0},angularDamping:a=0,isStatic:o=!1,noRotation:r=!1,affectedByGravity:l=!0,dynamicFriction:c=.4,staticFriction:y=.6}={}){const h=new p(t,s,e,o,r);if(h.radius=i,h.createCircle(),h.mass=1/0,h.inertia=1/0,h.linearDamping=n,h.angularDamping=a,c>y&&console.warn("Static friction should be higher than dynamic friction"),h.staticFriction=y,h.dynamicFriction=c,h.affectedByGravity=l,f(h),!h.isStatic){const t=Math.PI*h.radius*h.radius;h.mass=t*h.density,h.inertia=.5*h.mass*h.radius*h.radius}return h.needsUpdate=!0,h}function M(t,i){let e=1/0,n={x:0,y:0},o={x:0,y:0},r=t.transformedVertices,l=i.transformedVertices;for(let t=0;t<r.length;t++){let i=r[t],s=a(r[(t+1)%r.length],i);o.x=-s.y,o.y=s.x,o=c(o);let y=I(r,o),h=I(l,o),x=y.min,u=y.max,m=h.min,d=h.max;if(x>=d||m>=u)return{collision:!1};let p=Math.min(d-x,u-m);p<e&&(e=p,n.x=o.x,n.y=o.y)}for(let t=0;t<l.length;t++){let i=l[t],s=a(l[(t+1)%l.length],i);o.x=-s.y,o.y=s.x,o=c(o);let y=I(r,o),h=I(l,o),x=y.min,u=y.max,m=h.min,d=h.max;if(x>=d||m>=u)return{collision:!1};let p=Math.min(d-x,u-m);p<e&&(e=p,n.x=o.x,n.y=o.y)}let y=t.position;return s(a(i.position,y),n)<0&&(n.x=-n.x,n.y=-n.y),{collision:!0,normal:n,depth:e}}function b(t,i){let e,n,o,r,l=t.position,y=t.radius,h=i.transformedVertices,x=i.position,u={x:0,y:0},m=1/0,p={x:0,y:0},f=0;for(let t=0;t<h.length;t++){let i=h[t],s=a(h[(t+1)%h.length],i);p.x=-s.y,p.y=s.x,p=c(p);let x=I(h,p),d=U(l,y,p);if(e=x.min,n=x.max,o=d.min,r=d.max,e>=r||o>=n)return{collision:!1};f=Math.min(r-e,n-o),f<m&&(m=f,u.x=p.x,u.y=p.y)}let g=function(t,i){let s=-1,e=1/0;for(let n=0;n<i.length;n++){let a=d(i[n],t);a<e&&(e=a,s=n)}return s}(l,h);p=a(h[g],l),p=c(p);let v=I(h,p),V=U(l,y,p);return e=v.min,n=v.max,o=V.min,r=V.max,e>=r||o>=n?{collision:!1}:(f=Math.min(r-e,n-o),f<m&&(m=f,u.x=p.x,u.y=p.y),s(a(x,l),u)>0&&(u.x=-u.x,u.y=-u.y),{collision:!0,normal:u,depth:m})}function L(t,i){let s={x:0,y:0},e=1/0,n=t.position,o=i.position,r=t.radius,l=i.radius,y=d(o,n),h=r+l;return y>=h?{collision:!1}:(s=a(o,n),s=c(s),e=h-y,{collision:!0,normal:s,depth:e})}function S(t,i){const s=t.aabb,e=i.aabb;return s.minX<=e.maxX&&s.maxX>=e.minX&&s.minY<=e.maxY&&s.maxY>=e.minY}function C(t,i){let s=null;return t.isCircle||i.isCircle?t.isCircle&&i.isCircle?s=function(t,i){let s=t.position,e=i.position,o=t.radius,l=c(a(e,s));return{contact1:n(s,r(l,o)),contactCount:1}}(t,i):!t.isCircle&&i.isCircle?s=F(t,i):!i.isCircle&&t.isCircle?s=F(i,t):console.error("one of the polygons has an unsupported shape"):s=function(t,i){let s=null,e=null,n=0,a=t.transformedVertices,o=i.transformedVertices,r=1/0;for(let t=0;t<a.length;t++){let i=a[t];for(let t=0;t<o.length;t++){let a=B(i,o[t],o[(t+1)%o.length]),l=a.distanceSqrd,c=a.closestPoint;h(l,r)?x(c,s)||(e=c,n=2):l<r&&(r=l,n=1,s=c)}}for(let t=0;t<o.length;t++){let i=o[t];for(let t=0;t<a.length;t++){let o=B(i,a[t],a[(t+1)%a.length]),l=o.distanceSqrd,c=o.closestPoint;h(l,r)?x(c,s)||(e=c,n=2):l<r&&(r=l,n=1,s=c)}}return{contact1:s,contact2:e,contactCount:n}}(t,i),s}function F(t,i){let s=null,e=t.transformedVertices,n=i.position,a=1/0;for(let t=0;t<e.length;t++){let i=B(n,e[t],e[(t+1)%e.length]);i.distanceSqrd<a&&(a=i.distanceSqrd,s=i.closestPoint)}return{contact1:s,contactCount:1}}function I(t,i){let e=1/0,n=-1/0;const a=Math.hypot(i.x,i.y),o={x:i.x/a,y:i.y/a};for(let i=0;i<t.length;i++){const a=s(t[i],o);a<e&&(e=a),a>n&&(n=a)}return{min:e,max:n}}function U(t,i,e){let o=1,l=-1,y=r(c(e),i),h=n(t,y),x=a(t,y);if(o=s(h,e),l=s(x,e),o>l){let t=l;l=o,o=t}return{min:o,max:l}}function B(t,i,e){let a={x:e.x-i.x,y:e.y-i.y},o=s(a,{x:t.x-i.x,y:t.y-i.y})/m(a),l={x:0,y:0};return o<=0?(l.x=i.x,l.y=i.y):o>=1?(l.x=e.x,l.y=e.y):l=n(i,r(a,o)),{distanceSqrd:u(t,l),closestPoint:l}}function w(t,i,e){if(!t||!i)return!1;let n=a(i,t);if(m(n)<1e-6)return!0;let o=c(n);return Math.abs(s(o,e))<.1}class z{constructor(t,i,s,e,n,a,o){this.bodyA=t,this.bodyB=i,this.normal=s,this.depth=e,this.contact1=n,this.contact2=a,this.contactCount=o}}class D{constructor(t=[],i={x:0,y:0}){this.bodies=t,this.gravity=i,this.contacts=[],this.raList=[],this.rbList=[],this.impulseList=[],this.frictionImpulseList=[],this.jList=[]}step({dt:t,useRotations:i=!1,iterations:s=10}){for(let e=0;e<s;e++){for(let i of this.bodies)i.updateBody(t,this.gravity,s);const e=this.bodies.length;for(let t=0;t<e;t++)for(let s=t+1;s<e;s++){const e=this.bodies[t],n=this.bodies[s];S(e,n)&&(e.isStatic&&n.isStatic||this.collisionStep(e,n,i))}}}collisionStep(t,i,s){let e=this.resolveCollisions(t,i);if(e.collision){this.separateBodies(t,i,e);let n=C(t,i),a=new z(t,i,e.normal,e.depth,n.contact1,n.contact2,n.contactCount);s?this.resolveCollisionsRotationalAndFriction(a):this.resolveCollisionsBasicWithFriction(a)}}separateBodies(t,i,s){t.hasInfiniteMass||t.isStatic?i.move({x:s.normal.x*s.depth,y:s.normal.y*s.depth}):i.hasInfiniteMass||i.isStatic?t.move({x:-s.normal.x*s.depth,y:-s.normal.y*s.depth}):(t.move({x:-s.normal.x*s.depth/2,y:-s.normal.y*s.depth/2}),i.move({x:s.normal.x*s.depth/2,y:s.normal.y*s.depth/2}))}resolveCollisions(t,i){if(t.isStatic&&i.isStatic)return;let s=null;return t.isCircle||i.isCircle?t.isCircle&&i.isCircle?s=L(t,i):!t.isCircle&&i.isCircle?s=b(i,t):!i.isCircle&&t.isCircle?s=b(t,i):console.error("one of the polygons has an unsupported shape"):s=M(t,i),s}resolveCollisionsBasic(t){const i=t.bodyA,e=t.bodyB,n=t.normal;let o=a(e.linearVelocity,i.linearVelocity);if(s(o,n)>0)return;let r=0;r=i.mass===1/0||i.isStatic?e.restitution:e.mass===1/0||e.isStatic?i.restitution:Math.min(i.restitution,e.restitution);let l=-(1+r)*s(o,n);l/=i.invMass+e.invMass,i.isStatic||(i.linearVelocity.x-=l*i.invMass*n.x,i.linearVelocity.y-=l*i.invMass*n.y),e.isStatic||(e.linearVelocity.x+=l*e.invMass*n.x,e.linearVelocity.y+=l*e.invMass*n.y)}resolveCollisionsBasicWithFriction(t){const i=t.bodyA,e=t.bodyB,o=t.normal;let l=a(e.linearVelocity,i.linearVelocity),y=Math.sqrt(i.staticFriction*e.staticFriction),h=Math.sqrt(i.dynamicFriction*e.dynamicFriction);if(s(l,o)>0)return;let u,m=0;m=i.mass===1/0||i.isStatic?e.restitution:e.mass===1/0||e.isStatic?i.restitution:Math.min(i.restitution,e.restitution),u=-(1+m)*s(l,o),u/=i.invMass+e.invMass,i.isStatic||(i.linearVelocity.x-=u*i.invMass*o.x,i.linearVelocity.y-=u*i.invMass*o.y),e.isStatic||(e.linearVelocity.x+=u*e.invMass*o.x,e.linearVelocity.y+=u*e.invMass*o.y),l=a(e.linearVelocity,i.linearVelocity);let d=a(l,r(o,s(l,o)));if(x(d,{x:0,y:0}))return;d=c(d);let p,f=-s(l,d);f/=i.invMass+e.invMass,p=Math.abs(f)<u*y?r(d,f):r(d,-u*h),i.isStatic||(i.linearVelocity=a(i.linearVelocity,r(p,i.invMass))),e.isStatic||(e.linearVelocity=n(e.linearVelocity,r(p,e.invMass)))}resolveCollisionsRotational(t){const i=t.bodyA,o=t.bodyB,l=t.normal,c=t.contact1,y=t.contact2,h=t.contactCount;let x=0;x=i.mass===1/0||i.isStatic?o.restitution:o.mass===1/0||o.isStatic?i.restitution:Math.min(i.restitution,o.restitution);let u=[c,y];for(let t=0;t<h;t++)this.impulseList[t]={x:0,y:0},this.raList[t]={x:0,y:0},this.rbList[t]={x:0,y:0};for(let t=0;t<h;t++){let e={x:0,y:0},m={x:0,y:0};e=a(u[t],i.position),m=a(u[t],o.position),this.raList[t]=e,this.rbList[t]=m;let d={x:-e.y,y:e.x},p={x:-m.y,y:m.x},f=r(d,i.angularVelocity),g=r(p,o.angularVelocity),v=a(n(o.linearVelocity,g),n(i.linearVelocity,f)),V=s(v,l);if(V>0)continue;let M,b=s(d,l),L=s(p,l),S=i.invMass+o.invMass+b*b*i.invInertia+L*L*o.invInertia;2===h&&w(c,y,l)?(v=a(o.linearVelocity,i.linearVelocity),M=-(1+x)*s(v,l),M/=i.invMass+o.invMass,M/=h):(M=-(1+x)*V,M/=S,M/=h);let C={x:0,y:0};C.x=M*l.x,C.y=M*l.y,this.impulseList[t]=C}for(let t=0;t<h;t++){let s=this.impulseList[t],n=this.raList[t],a=this.rbList[t];i.isStatic||(i.linearVelocity.x+=-s.x*i.invMass,i.linearVelocity.y+=-s.y*i.invMass),i.rotates||(i.angularVelocity+=-e(n,s)*i.invInertia),o.isStatic||(o.linearVelocity.x+=s.x*o.invMass,o.linearVelocity.y+=s.y*o.invMass),o.rotates||(o.angularVelocity+=e(a,s)*o.invInertia)}}resolveCollisionsRotationalAndFriction(t){const i=t.bodyA,o=t.bodyB,l=t.normal,y=t.contact1,h=t.contact2,u=t.contactCount;let m=0;m=i.mass===1/0||i.isStatic?o.restitution:o.mass===1/0||o.isStatic?i.restitution:Math.min(i.restitution,o.restitution);let d=Math.sqrt(i.staticFriction*o.staticFriction),p=Math.sqrt(i.dynamicFriction*o.dynamicFriction),f=[y,h];for(let t=0;t<u;t++)this.impulseList[t]={x:0,y:0},this.frictionImpulseList[t]={x:0,y:0},this.jList[t]=0,this.raList[t]={x:0,y:0},this.rbList[t]={x:0,y:0};for(let t=0;t<u;t++){let e={x:0,y:0},c={x:0,y:0};e=a(f[t],i.position),c=a(f[t],o.position),this.raList[t]=e,this.rbList[t]=c;let x={x:-e.y,y:e.x},d={x:-c.y,y:c.x},p=r(x,i.angularVelocity),g=r(d,o.angularVelocity),v=a(n(o.linearVelocity,g),n(i.linearVelocity,p)),V=s(v,l);if(V>0)continue;let M,b=s(x,l),L=s(d,l),S=i.invMass+o.invMass+b*b*i.invInertia+L*L*o.invInertia;2===u&&w(y,h,l)?(v=a(o.linearVelocity,i.linearVelocity),M=-(1+m)*s(v,l),M/=i.invMass+o.invMass,M/=u):(M=-(1+m)*V,M/=S,M/=u),this.jList[t]=M;let C={x:0,y:0};C.x=M*l.x,C.y=M*l.y,this.impulseList[t]=C}for(let t=0;t<u;t++){let s=this.impulseList[t],n=this.raList[t],a=this.rbList[t];i.isStatic||(i.linearVelocity.x+=-s.x*i.invMass,i.linearVelocity.y+=-s.y*i.invMass),i.rotates||(i.angularVelocity+=-e(n,s)*i.invInertia),o.isStatic||(o.linearVelocity.x+=s.x*o.invMass,o.linearVelocity.y+=s.y*o.invMass),o.rotates||(o.angularVelocity+=e(a,s)*o.invInertia)}for(let t=0;t<u;t++){let e={x:0,y:0},y={x:0,y:0};e=a(f[t],i.position),y=a(f[t],o.position),this.raList[t]=e,this.rbList[t]=y;let h={x:-e.y,y:e.x},m={x:-y.y,y:y.x},g=r(h,i.angularVelocity),v=r(m,o.angularVelocity),V=a(n(o.linearVelocity,v),n(i.linearVelocity,g)),M=a(V,r(l,s(V,l)));if(x(M,{x:0,y:0}))continue;M=c(M);let b=s(h,M),L=s(m,M),S=i.invMass+o.invMass+b*b*i.invInertia+L*L*o.invInertia,C=this.jList[t],F=0;F=-s(V,M),F/=S,F/=u;let I={x:0,y:0};Math.abs(F)<=C*d?(I.x=F*M.x,I.y=F*M.y):(I.x=-C*M.x*p,I.y=-C*M.y*p),this.frictionImpulseList[t]=I}for(let t=0;t<u;t++){let s=this.frictionImpulseList[t],n=this.raList[t],a=this.rbList[t];this.shouldApplyFriction(l)||(i.isStatic||(i.linearVelocity.x+=-s.x*i.invMass,i.linearVelocity.y+=-s.y*i.invMass),i.rotates||(i.angularVelocity+=-e(n,s)*i.invInertia),o.isStatic||(o.linearVelocity.x+=s.x*o.invMass,o.linearVelocity.y+=s.y*o.invMass),o.rotates||(o.angularVelocity+=e(a,s)*o.invInertia))}}shouldApplyFriction(t){if(0!==this.gravity.x||0!==this.gravity.y){const i=c(this.gravity);let e=c(t);s(e,i)>0&&(e=r(e,-1));return s(e,i)>-.75}return!1}}export{t as AABB,S as AABBvsAABB,D as PhysWorld,p as Rigidbody,M as SAT,n as addVectors,h as almostEqual,x as almostEqualVector,L as circleVsCircle,b as circleVsPolygon,y as clamp,g as createBodyBox,V as createBodyCircle,v as createBodyTriangle,e as crossProduct,d as distance,u as distanceSquared,s as dotProduct,m as lengthSquared,l as magnitude,o as multiplyVectors,c as normalize,r as scaleVector,a as subtractVectors};
